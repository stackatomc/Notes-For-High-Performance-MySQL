# 第4章 Schema与数据类型优化

标签：MySQL


---

## 通过逻辑设计和物理设计优化

- 一些优化方法
	- 反范式的设计
	- 添加计数表和汇总表
-缺点
	- 维护成本较高

---

## 简单原则

- 正确且更小的通常更好。
	- 占用更少的磁盘，内存和CPU缓存，处理时所需要的CPU周期也更少。
	- 注意确定值得存储范围，放置超出或后续修改
- 简单得数据类型更好
	- 操作其需要更少得CPU周期
	- 例子:用MySQL内建得数据类型date\time等，而不是字符串来存储日期和时间；用整数存储IP地址
- 尽量避免NULL
	- 因为难以优化，且会使用更多得存储空间；索引、索引统计和值都比较复杂。当可为NULL的列被索引是，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引变成可变大小的索引
	- 例外：InnoDB使用单独的位存储NULL值，所以对于系数数据有很好的空间效率，但这点不适用于MyISAM
- 选择步骤通常是
	- 确定数据类型
	- 根据精度等，选择具体类型，存储长度和范围不一样、精度不同、需要的物理空格键(磁盘和内存)也会不同，并且有一些特殊的行为和属性需要注意
	- 例如：TIMESTAMP只使用DATETIMIE一半的存储空间，但可存储相同类型的数据：时间和日期，精确到秒。而TIMESTAMP允许的时间范围也要小得多

---

## 常见数据类型

### 整数类型
	
- UNISGNED属性。可让整数上限提高一倍，根据实际情况选择
- MySQLK可唯整数类型指定宽度，如INT(11)，但只对交互工具显示字数上有影响，对存储和计算来说，INT(11)和INT(20)是相同的

### 实数类型
	
- 实数指带有小数部分的数字，FLOAT和DOUBLE支持不精准计算，使用标准的浮点运算进行近似计算。而DECIMAL类型用于存储精确的小数但CPU不支持对DECIMAL直接记数。在MySQL5.0及以后已实现
- 浮点类型存储同样范围的值时，占用比DECIMAL更少的空间。Double占用8个字节，相比FLOAT有更高的精度和更大的范围，MySQL使用DOUBLE作为内部浮点计算的类型
- DECIMAL减少使用，空间和计算开销太大，可用于存储理财数据时，数据量太大可考虑BIGINT代替DECIMAL

### 字符串类型

- VARCHAR 比定长类型更节省空间，但VARCHAR需要1或2个额外字节记录字符串的长度
- CHAR 是定长的，默认删除末尾空格。适合存储很短的字符串，或者同所有值接近同一个长度，例如存储密码的MD5值，不容易产生碎片。且没有VARCHAR产生的额外字节记录长度
- 最好的策略是只分配真正需要的空间，更长的列通常会消耗更多的内存

### BLOG和TEXT类型

- 为存储很大的数据而设计的字符串数据类型
- BLOG采用二进制，没有排序规则和字符集
- TEXT采用字符方式存储，有排序规则和字符集
- Memory引擎不支持BLOG和TEXT类型，若查询到将使用内存临时表，导致严重的性能开销

### 枚举类型

- ENUM 有时使用没剧烈代替常用的字符串类型
	- MySQL在存储枚举时非常紧凑.极大地让表的大小缩小
	- MySQL在内部会将每个值在列表中的位置保存为整数，以数字-字符串映射。枚举字段按照内部存储的整数而不是定义的字符串进行排序

```
mysql>CREATE TABLE enum_test(
e ENUM('fish','apple','dog') NOT NULL );
mysql>INSERT INTO enum_test(e) VALUES('fish'),('dog'),('apple');
mysql> SELECT e+0 FROM enum_Test;
+-----+
| e+0 |
+-----+
|   1 |
|   3 |
|   2 |
+-----+
3 rows in set (0.00 sec)

mysql> SELECT e FROM enum_test ORDER BY e;
+-------+
| e     |
+-------+
| fish  |
| apple |
| dog   |
+-------+
3 rows in set (0.00 sec)
```

### 日期和时间类型

- DATETIME YYYYMMDDHHMMSS格式
- TIMESTAMP 从1970.1.1午夜到现在地秒数。且依赖时区所以不同时区将不同
- 建议使用TIMESTAMP，比DATETIME空间少，且处理格式更方便

### 位数据类型

- BIT 注意a BIT(8) 检索时a为字符码对应地字符串（如字符码57对应9），若在数字上下文场景中将得到数字57（如a+0）
- 不一定功能节省空间，且结果与数据易混淆，谨慎使用

### SET类型

- 适合保存很多true/false值，合并这些列到一个SET数据类型，有效利用存储空间
- FIND_IN_SET和FILED()函数
- 缺点：难以查询，查询语句不便于理解
```
mysql>CREATE TABLE ac1(
perms SET('CAN_READ','CAB_WRITE','CAN_DELETE')NOT NULL
);
mysql>INSERT INTO ac1(perms) VALUES('CAN_READ,CAB_DELETE');
mysql>SELECT perms FROM ac1 WHERE FIND_IN_SET('AN_READ',perms);
```

---

## 选择标识符

- 方法
	- 考虑存储类型和需要涉及的计算和执行使用、比较等对数据类型的要求
	- 一旦选定了一种类型，尽量所有关联表中使用同样的类型，包括UNSIGNED等属性，避免不同数据类型导致的性能问题或隐式类型转换出错
	- 尽量学则最小的数据类型
- 具体
	- 整数类型。最佳，AUTO_INCREMENT，整数通常是标识列最好的选择
	- ENUM和SET类型，适合存储固定信息，只用于包含只包含固定状态或者类型的静态“定义类”。显然不建议使用
	- 字符串类型。应该避免，因为很浪费空间，且慢
	- 随机的ND5()、SHA1()可能导致索引写入过于分散，导致SELECT语句变慢
- 注意
	- 避免直接导入脚本，或使用schema迁移程序等。单纯面向对象的开发思想，难以避免数据存储上存储的隐患。对具体数据的存储类型需要严格一表一行的排查，在真实数据上做测试，这样就不会太晚才发现性能问题
	- 


---

##